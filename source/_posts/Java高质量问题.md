---
title: Java高质量问题
tags:
  - Java
  - 题目
categories: 好奇尚异
abbrlink: 12d199bb
date: 2019-01-29 00:35:16
updated: 2019-02-12 18:23:28
---

- 千万不能沉溺于回报周期短的、微小的正反馈不能自拔，而要找到让你一路走下去的真正动力。得失心不要太重，目光不要太短，人生百年，说短也短，说长，其实也挺长的。
# 题目1、MySQL中 like`%%`和`find_in_set`的区别
`find_in_set`对于查找以英文逗号分隔的字段，更加具有精确性

# 题目2、Java类初始化顺序
基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>基类构造函数——>派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>派生类构造函数

# 题目3、一个java文件有3个类，编译后有几个class文件
文件中有几个类编译后就有几个class文件。

# 题目4、局部变量为何必须要显式地赋值才可以使用
成员变量是可以不经初始化的，在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显式赋予初始值，javac不是推断不出不可以这样做，而是没有这样做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。

# 题目5、写一个死锁
> 死锁概念及产生原理
    概念：多个并发进程因争夺系统资源而产生相互等待的现象。
    原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。
    本质原因：
        1）、系统资源有限。
        2）、进程推进顺序不合理。
死锁产生的4个必要条件
    1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
    2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
    3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
    4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。
当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。
思想为：定义两个ArrayList,将他们都加上锁A,B，线程1,2，1拿住了锁A ，请求锁B，2拿住了锁B请求锁A，在等待对方释放锁的过程中谁也不让出已获得的锁。
```java
public class DeadLock {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(4, 5, 6);
        new Thread(()-> {
            synchronized (list1){
                for (Integer o : list1) {
                    System.out.println(o);
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (list2) {
                    for (Integer o : list2) {
                        System.out.println(o);
                    }
                }
            }
        }).start();
        new Thread(()-> {
            synchronized (list2){
                for (Integer o : list2) {
                    System.out.println(o);
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (list1) {
                    for (Integer o : list1) {
                        System.out.println(o);
                    }
                }
            }
        }).start();
    }
}

```